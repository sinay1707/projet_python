# -*- coding: utf-8 -*-
"""main1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/sinay1707/5296080175011141c4565ff917cbe3b0/main1.ipynb
"""

#IMPORT


import sys
import numpy as np
import matplotlib.pyplot as plt
np.set_printoptions(threshold=sys.maxsize)
np.set_printoptions(suppress = True)

"""PREMIER JEU DE DONNEES FACILE """

#FICHIER DONNEES SIMPLE

data = np.loadtxt("Test-Framedata - OK Data.txt")

image = np.array(data) 


#PLOT 


# plt.figure(figsize = (24,20),dpi=150)
# plt.imshow(image,cmap = 'hot',aspect = 'auto')

# plt.title("Trace de particules", size = 20, weight = 'bold')
# cb = plt.colorbar(shrink=1.05,label = 'Energie en keV')
# cb.ax.tick_params(labelsize=16)
# font = {'family' : 'serif',
#         'color'  : 'black',
#         'weight' : 'normal',
#         'size'   : 20,
#         }
# cb.set_label('Energie en keV',fontdict=font)
# plt.xticks(fontsize=16)
# plt.yticks(fontsize=16)


# plt.savefig("firstfile.png")

"""DEUXIEME JEU DE DONNEES """

#FICHIER PLUS DIFFIC


M = np.zeros((256,256))

x, y, energy = np.loadtxt("data.txt", unpack ='True')
n = x.size

x = x.astype(int)
y = y.astype(int)

for i in range(n):
    M[x[i],y[i]] = M[x[i],y[i]] + energy[i]


#PLOT

# plt.figure(figsize = (24,20),dpi=150)
# plt.imshow(M,cmap = 'hot',aspect = 'auto')

# plt.title("Trace de particules", size = 20, weight = 'bold')
# cb = plt.colorbar(shrink=1.05,label = 'Energie en keV')
# cb.ax.tick_params(labelsize=16)
# font = {'family' : 'serif',
#         'color'  : 'black',
#         'weight' : 'normal',
#         'size'   : 20,
#         }
# cb.set_label('Energie en keV',fontdict=font)
# plt.xticks(fontsize=16)
# plt.yticks(fontsize=16)

# plt.savefig('secfile.png')

# np.savetxt("array.txt", M, fmt="%s")

# plt.axis('off')
# plt.savefig('onlysec.png')

"""STOCKAGE D'INDICE ET D'ENERGIE"""

#STOCKAGE DINDICE ET ENERGIE 1 (AFFICHE UNE ERREUR)


#METHODE 1 


# stk_index = []

# stk_value = []

# wh = np.where(M>0)  #tuple contenant les indices des valeurs > 0

# whm = np.asarray(wh) # je transforme ce tuple en matrice afin de pouvoir travailler dessus

# for i in range(whm.size):#on va de 0 à la longueur de la matrice qu'on a

# #np.take va prendre l'indice de la matrice et extract va prendre la valeur à cette indice

#   stk_index = np.append(stk_index,np.take(wh,i))
#   stk_value = np.append(stk_value, np.extract(M>0,M)[i])
  
#   #print(np.take(wh,i),np.extract(M>0,M)[i])


#BROUILLON

# sup = np.array([-1,45,-32,-25,12])

# ext = np.where(sup>0)
# extm = np.asarray(ext)
# for i in range(extm.size):
#     print(np.take(ext,i))

#alternative
# xl = []
# yl = []
# enerl = []
# for i in x:
#   xl = np.append(xl,i)
# for i in y : 
#   yl = np.append(yl,i)
# for i in energy:
#   enerl = np.append(enerl,i)

# xll = xl.tolist()
# yll = yl.tolist()
# enerll = enerl.tolist()

# m = len(xll)
# for i in range(m):
#   xll[i] = int(xll[i])
#   yll[i] = int(yll[i])
# tot = []
# for i in range(m):
#   tot.append([xll[i],yll[i],enerll[i]])

#ALGORTIHME D'ISOLEMENT DE TRACE

stock_index = [] #index dont les valeurs seront > 0

stock_value = [] #Valeur > 0

extract = np.extract(M>0,M) #matrice des valeurs de M > 0

tpl = np.where(M>0)  #tuple contenant les indices des valeurs > 0

m_index = np.asarray(tpl) # je transforme ce tuple en matrice afin de pouvoir travailler dessus



for i in range(m_index.size):  

#np.take va prendre l'indice de la matrice et extract va prendre la valeur à cette indice

  stock_index.append(np.take(tpl,i))


for i in range(extract.size):
  stock_value.append(extract[i])
#np.take va prendre l'indice de la matrice et extract va prendre la valeur à cette indice


print(stock_index) #----> longueur = 3066 (X et Y)
print("")
print("")
print(stock_value) #----> longueur = 1533

